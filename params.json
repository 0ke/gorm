{"name":"Gorm","tagline":"The fantastic ORM library for Golang, aims to be developer friendly.","body":"# GORM\r\n\r\n[![Join the chat at https://gitter.im/jinzhu/gorm](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/jinzhu/gorm?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\r\n\r\nThe fantastic ORM library for Golang, aims to be developer friendly.\r\n\r\n[![wercker status](https://app.wercker.com/status/0cb7bb1039e21b74f8274941428e0921/s/master \"wercker status\")](https://app.wercker.com/project/bykey/0cb7bb1039e21b74f8274941428e0921)\r\n\r\n## Overview\r\n\r\n* Full-Featured ORM (almost)\r\n* Chainable API\r\n* Auto Migrations\r\n* Relations (Has One, Has Many, Belongs To, Many To Many, [Polymorphism](#polymorphism))\r\n* Callbacks (Before/After Create/Save/Update/Delete/Find)\r\n* Preloading (eager loading)\r\n* Transactions\r\n* Embed Anonymous Struct\r\n* Soft Deletes\r\n* Customizable Logger\r\n* Iteration Support via [Rows](#row--rows)\r\n* Every feature comes with tests\r\n* Developer Friendly\r\n\r\n# Getting Started\r\n\r\n## Install\r\n\r\n```\r\ngo get -u github.com/jinzhu/gorm\r\n```\r\n\r\n## Documentation \r\n\r\n[![GoDoc](https://godoc.org/github.com/jinzhu/gorm?status.svg)](https://godoc.org/github.com/jinzhu/gorm)\r\n\r\n`go doc` format documentation for this project can be viewed online without\r\ninstalling the package by using the GoDoc page at:\r\nhttp://godoc.org/github.com/jinzhu/gorm\r\n\r\n## Table of Contents\r\n\r\n- [Define Models (Structs)](#define-models-structs)\r\n- [Conventions](#conventions)\r\n- [Initialize Database](#initialize-database)\r\n- [Migration](#migration)\r\n- [Basic CRUD](#basic-crud)\r\n  - [Create](#create-record)\r\n  - [Query](#query)\r\n      - [Query With Where (Plain SQL)](#query-with-where-plain-sql)\r\n      - [Query With Where (Struct & Map)](#query-with-where-struct--map)\r\n      - [Query With Not](#query-with-not)\r\n      - [Query With Inline Condition](#query-with-inline-condition)\r\n      - [Query With Or](#query-with-or)\r\n      - [Query Chains](#query-chains)\r\n      - [Preloading (Eager loading)](#preloading-eager-loading)\r\n  - [Update](#update)\r\n      - [Update Without Callbacks](#update-without-callbacks)\r\n      - [Batch Updates](#batch-updates)\r\n      - [Update with SQL Expression](#update-with-sql-expression)\r\n  - [Delete](#delete)\r\n      - [Batch Delete](#batch-delete)\r\n      - [Soft Delete](#soft-delete)\r\n- [Associations](#associations)\r\n    - [Has One](#has-one)\r\n    - [Belongs To](#belongs-to)\r\n    - [Has Many](#has-many)\r\n    - [Many To Many](#many-to-many)\r\n    - [Polymorphism](#polymorphism)\r\n- [Advanced Usage](#advanced-usage)\r\n\t- [FirstOrInit](#firstorinit)\r\n\t- [FirstOrCreate](#firstorcreate)\r\n\t- [Select](#select)\r\n\t- [Order](#order)\r\n\t- [Limit](#limit)\r\n\t- [Offset](#offset)\r\n\t- [Count](#count)\r\n\t- [Pluck](#pluck)\r\n\t- [Raw SQL](#raw-sql)\r\n\t- [Row & Rows](#row--rows)\r\n\t- [Scan](#scan)\r\n\t- [Group & Having](#group--having)\r\n\t- [Joins](#joins)\r\n\t- [Transactions](#transactions)\r\n\t- [Scopes](#scopes)\r\n\t- [Callbacks](#callbacks)\r\n\t- [Specifying The Table Name](#specifying-the-table-name)\r\n\t- [Error Handling](#error-handling)\r\n\t- [Logger](#logger)\r\n\t- [Existing Schema](#existing-schema)\r\n\t- [Composite Primary Key](#composite-primary-key)\r\n\t- [Database Indexes & Foreign Key](#database-indexes--foreign-key)\r\n\t- [Default values](#default-values)\r\n\t- [More examples with query chain](#more-examples-with-query-chain)\r\n\r\n## Define Models (Structs)\r\n\r\n```go\r\ntype User struct {\r\n\tID           int\r\n\tBirthday     time.Time\r\n\tAge          int\r\n\tName         string  `sql:\"size:255\"` // Default size for string is 255, you could reset it with this tag\r\n\tNum          int     `sql:\"AUTO_INCREMENT\"`\r\n\tCreatedAt    time.Time\r\n\tUpdatedAt    time.Time\r\n\tDeletedAt    *time.Time\r\n\r\n\tEmails            []Email         // One-To-Many relationship (has many)\r\n\tBillingAddress    Address         // One-To-One relationship (has one)\r\n\tBillingAddressID  sql.NullInt64   // Foreign key of BillingAddress\r\n\tShippingAddress   Address         // One-To-One relationship (has one)\r\n\tShippingAddressID int             // Foreign key of ShippingAddress\r\n\tIgnoreMe          int `sql:\"-\"`   // Ignore this field\r\n\tLanguages         []Language `gorm:\"many2many:user_languages;\"` // Many-To-Many relationship, 'user_languages' is join table\r\n}\r\n\r\ntype Email struct {\r\n\tID      int\r\n\tUserID  int     `sql:\"index\"` // Foreign key (belongs to), tag `index` will create index for this field when using AutoMigrate\r\n\tEmail   string  `sql:\"type:varchar(100);unique_index\"` // Set field's sql type, tag `unique_index` will create unique index\r\n\tSubscribed bool\r\n}\r\n\r\ntype Address struct {\r\n\tID       int\r\n\tAddress1 string         `sql:\"not null;unique\"` // Set field as not nullable and unique\r\n\tAddress2 string         `sql:\"type:varchar(100);unique\"`\r\n\tPost     sql.NullString `sql:\"not null\"`\r\n}\r\n\r\ntype Language struct {\r\n\tID   int\r\n\tName string `sql:\"index:idx_name_code\"` // Create index with name, and will create combined index if find other fields defined same name\r\n\tCode string `sql:\"index:idx_name_code\"` // `unique_index` also works\r\n}\r\n```\r\n\r\n## Conventions\r\n\r\n* Table name is the plural of struct name's snake case, you can disable pluralization with `db.SingularTable(true)`, or [Specifying The Table Name For A Struct Permanently With TableName](#specifying-the-table-name-for-a-struct-permanently-with-tablename)\r\n\r\n```go\r\ntype User struct{} // struct User's database table name is \"users\" by default, will be \"user\" if you disabled pluralisation\r\n```\r\n\r\n* Column name is the snake case of field's name\r\n* Use `ID` field as primary key\r\n* Use `CreatedAt` to store record's created time if field exists\r\n* Use `UpdatedAt` to store record's updated time if field exists\r\n* Use `DeletedAt` to store record's deleted time if field exists [Soft Delete](#soft-delete)\r\n* Gorm provide a default model struct, you could embed it in your struct\r\n\r\n```go\r\ntype Model struct {\r\n\tID        uint `gorm:\"primary_key\"`\r\n\tCreatedAt time.Time\r\n\tUpdatedAt time.Time\r\n\tDeletedAt *time.Time\r\n}\r\n\r\ntype User struct {\r\n\tgorm.Model\r\n\tName string\r\n}\r\n```\r\n\r\n## Initialize Database\r\n\r\n```go\r\nimport (\r\n\t\"github.com/jinzhu/gorm\"\r\n\t_ \"github.com/lib/pq\"\r\n\t_ \"github.com/go-sql-driver/mysql\"\r\n\t_ \"github.com/mattn/go-sqlite3\"\r\n)\r\n\r\ndb, err := gorm.Open(\"postgres\", \"user=gorm dbname=gorm sslmode=disable\")\r\n// db, err := gorm.Open(\"foundation\", \"dbname=gorm\") // FoundationDB.\r\n// db, err := gorm.Open(\"mysql\", \"user:password@/dbname?charset=utf8&parseTime=True&loc=Local\")\r\n// db, err := gorm.Open(\"sqlite3\", \"/tmp/gorm.db\")\r\n\r\n// You can also use an existing database connection handle\r\n// dbSql, _ := sql.Open(\"postgres\", \"user=gorm dbname=gorm sslmode=disable\")\r\n// db, _ := gorm.Open(\"postgres\", dbSql)\r\n\r\n// Get database connection handle [*sql.DB](http://golang.org/pkg/database/sql/#DB)\r\ndb.DB()\r\n\r\n// Then you could invoke `*sql.DB`'s functions with it\r\ndb.DB().Ping()\r\ndb.DB().SetMaxIdleConns(10)\r\ndb.DB().SetMaxOpenConns(100)\r\n\r\n// Disable table name's pluralization\r\ndb.SingularTable(true)\r\n```\r\n\r\n## Migration\r\n\r\n```go\r\n// Create table\r\ndb.CreateTable(&User{})\r\ndb.Set(\"gorm:table_options\", \"ENGINE=InnoDB\").CreateTable(&User{})\r\n\r\n// Drop table\r\ndb.DropTable(&User{})\r\n\r\n// ModifyColumn\r\ndb.Model(&User{}).ModifyColumn(\"description\", \"text\")\r\n\r\n// DropColumn\r\ndb.Model(&User{}).DropColumn(\"description\")\r\n\r\n// Automating Migration\r\ndb.AutoMigrate(&User{})\r\ndb.Set(\"gorm:table_options\", \"ENGINE=InnoDB\").AutoMigrate(&User{})\r\ndb.AutoMigrate(&User{}, &Product{}, &Order{})\r\n// Feel free to change your struct, AutoMigrate will keep your database up-to-date.\r\n// AutoMigrate will ONLY add *new columns* and *new indexes*,\r\n// WON'T update current column's type or delete unused columns, to protect your data.\r\n// If the table is not existing, AutoMigrate will create the table automatically.\r\n```\r\n\r\n# Basic CRUD\r\n\r\n## Create Record\r\n\r\n```go\r\nuser := User{Name: \"Jinzhu\", Age: 18, Birthday: time.Now()}\r\n\r\ndb.NewRecord(user) // => returns `true` if primary key is blank\r\n\r\ndb.Create(&user)\r\n\r\ndb.NewRecord(user) // => return `false` after `user` created\r\n\r\n// Associations will be inserted automatically when save the record\r\nuser := User{\r\n\tName:            \"jinzhu\",\r\n\tBillingAddress:  Address{Address1: \"Billing Address - Address 1\"},\r\n\tShippingAddress: Address{Address1: \"Shipping Address - Address 1\"},\r\n\tEmails:          []Email{{Email: \"jinzhu@example.com\"}, {Email: \"jinzhu-2@example@example.com\"}},\r\n\tLanguages:       []Language{{Name: \"ZH\"}, {Name: \"EN\"}},\r\n}\r\n\r\ndb.Create(&user)\r\n//// BEGIN TRANSACTION;\r\n//// INSERT INTO \"addresses\" (address1) VALUES (\"Billing Address - Address 1\");\r\n//// INSERT INTO \"addresses\" (address1) VALUES (\"Shipping Address - Address 1\");\r\n//// INSERT INTO \"users\" (name,billing_address_id,shipping_address_id) VALUES (\"jinzhu\", 1, 2);\r\n//// INSERT INTO \"emails\" (user_id,email) VALUES (111, \"jinzhu@example.com\");\r\n//// INSERT INTO \"emails\" (user_id,email) VALUES (111, \"jinzhu-2@example.com\");\r\n//// INSERT INTO \"languages\" (\"name\") VALUES ('ZH');\r\n//// INSERT INTO user_languages (\"user_id\",\"language_id\") VALUES (111, 1);\r\n//// INSERT INTO \"languages\" (\"name\") VALUES ('EN');\r\n//// INSERT INTO user_languages (\"user_id\",\"language_id\") VALUES (111, 2);\r\n//// COMMIT;\r\n```\r\n\r\nRefer [Associations](#associations) for more details\r\n\r\n## Query\r\n\r\n```go\r\n// Get the first record\r\ndb.First(&user)\r\n//// SELECT * FROM users ORDER BY id LIMIT 1;\r\n\r\n// Get the last record\r\ndb.Last(&user)\r\n//// SELECT * FROM users ORDER BY id DESC LIMIT 1;\r\n\r\n// Get all records\r\ndb.Find(&users)\r\n//// SELECT * FROM users;\r\n\r\n// Get record with primary key\r\ndb.First(&user, 10)\r\n//// SELECT * FROM users WHERE id = 10;\r\n```\r\n\r\n### Query With Where (Plain SQL)\r\n\r\n```go\r\n// Get the first matched record\r\ndb.Where(\"name = ?\", \"jinzhu\").First(&user)\r\n//// SELECT * FROM users WHERE name = 'jinzhu' limit 1;\r\n\r\n// Get all matched records\r\ndb.Where(\"name = ?\", \"jinzhu\").Find(&users)\r\n//// SELECT * FROM users WHERE name = 'jinzhu';\r\n\r\ndb.Where(\"name <> ?\", \"jinzhu\").Find(&users)\r\n\r\n// IN\r\ndb.Where(\"name in (?)\", []string{\"jinzhu\", \"jinzhu 2\"}).Find(&users)\r\n\r\n// LIKE\r\ndb.Where(\"name LIKE ?\", \"%jin%\").Find(&users)\r\n\r\n// AND\r\ndb.Where(\"name = ? and age >= ?\", \"jinzhu\", \"22\").Find(&users)\r\n\r\n// Time\r\ndb.Where(\"updated_at > ?\", lastWeek).Find(&users)\r\n\r\ndb.Where(\"created_at BETWEEN ? AND ?\", lastWeek, today).Find(&users)\r\n```\r\n\r\n### Query With Where (Struct & Map)\r\n\r\n```go\r\n// Struct\r\ndb.Where(&User{Name: \"jinzhu\", Age: 20}).First(&user)\r\n//// SELECT * FROM users WHERE name = \"jinzhu\" AND age = 20 LIMIT 1;\r\n\r\n// Map\r\ndb.Where(map[string]interface{}{\"name\": \"jinzhu\", \"age\": 20}).Find(&users)\r\n//// SELECT * FROM users WHERE name = \"jinzhu\" AND age = 20;\r\n\r\n// Slice of primary keys\r\ndb.Where([]int64{20, 21, 22}).Find(&users)\r\n//// SELECT * FROM users WHERE id IN (20, 21, 22);\r\n```\r\n\r\n### Query With Not\r\n\r\n```go\r\ndb.Not(\"name\", \"jinzhu\").First(&user)\r\n//// SELECT * FROM users WHERE name <> \"jinzhu\" LIMIT 1;\r\n\r\n// Not In\r\ndb.Not(\"name\", []string{\"jinzhu\", \"jinzhu 2\"}).Find(&users)\r\n//// SELECT * FROM users WHERE name NOT IN (\"jinzhu\", \"jinzhu 2\");\r\n\r\n// Not In slice of primary keys\r\ndb.Not([]int64{1,2,3}).First(&user)\r\n//// SELECT * FROM users WHERE id NOT IN (1,2,3);\r\n\r\ndb.Not([]int64{}).First(&user)\r\n//// SELECT * FROM users;\r\n\r\n// Plain SQL\r\ndb.Not(\"name = ?\", \"jinzhu\").First(&user)\r\n//// SELECT * FROM users WHERE NOT(name = \"jinzhu\");\r\n\r\n// Struct\r\ndb.Not(User{Name: \"jinzhu\"}).First(&user)\r\n//// SELECT * FROM users WHERE name <> \"jinzhu\";\r\n```\r\n\r\n### Query With Inline Condition\r\n\r\n```go\r\n// Get by primary key\r\ndb.First(&user, 23)\r\n//// SELECT * FROM users WHERE id = 23 LIMIT 1;\r\n\r\n// Plain SQL\r\ndb.Find(&user, \"name = ?\", \"jinzhu\")\r\n//// SELECT * FROM users WHERE name = \"jinzhu\";\r\n\r\ndb.Find(&users, \"name <> ? AND age > ?\", \"jinzhu\", 20)\r\n//// SELECT * FROM users WHERE name <> \"jinzhu\" AND age > 20;\r\n\r\n// Struct\r\ndb.Find(&users, User{Age: 20})\r\n//// SELECT * FROM users WHERE age = 20;\r\n\r\n// Map\r\ndb.Find(&users, map[string]interface{}{\"age\": 20})\r\n//// SELECT * FROM users WHERE age = 20;\r\n```\r\n\r\n### Query With Or\r\n\r\n```go\r\ndb.Where(\"role = ?\", \"admin\").Or(\"role = ?\", \"super_admin\").Find(&users)\r\n//// SELECT * FROM users WHERE role = 'admin' OR role = 'super_admin';\r\n\r\n// Struct\r\ndb.Where(\"name = 'jinzhu'\").Or(User{Name: \"jinzhu 2\"}).Find(&users)\r\n//// SELECT * FROM users WHERE name = 'jinzhu' OR name = 'jinzhu 2';\r\n\r\n// Map\r\ndb.Where(\"name = 'jinzhu'\").Or(map[string]interface{}{\"name\": \"jinzhu 2\"}).Find(&users)\r\n```\r\n\r\n### Query Chains\r\n\r\nGorm has a chainable API, you could use it like this\r\n\r\n```go\r\ndb.Where(\"name <> ?\",\"jinzhu\").Where(\"age >= ? and role <> ?\",20,\"admin\").Find(&users)\r\n//// SELECT * FROM users WHERE name <> 'jinzhu' AND age >= 20 AND role <> 'admin';\r\n\r\ndb.Where(\"role = ?\", \"admin\").Or(\"role = ?\", \"super_admin\").Not(\"name = ?\", \"jinzhu\").Find(&users)\r\n```\r\n\r\n### Preloading (Eager loading)\r\n\r\n```go\r\ndb.Preload(\"Orders\").Find(&users)\r\n//// SELECT * FROM users;\r\n//// SELECT * FROM orders WHERE user_id IN (1,2,3,4);\r\n\r\ndb.Preload(\"Orders\", \"state NOT IN (?)\", \"cancelled\").Find(&users)\r\n//// SELECT * FROM users;\r\n//// SELECT * FROM orders WHERE user_id IN (1,2,3,4) AND state NOT IN ('cancelled');\r\n\r\ndb.Where(\"state = ?\", \"active\").Preload(\"Orders\", \"state NOT IN (?)\", \"cancelled\").Find(&users)\r\n//// SELECT * FROM users WHERE state = 'active';\r\n//// SELECT * FROM orders WHERE user_id IN (1,2) AND state NOT IN ('cancelled');\r\n\r\ndb.Preload(\"Orders\").Preload(\"Profile\").Preload(\"Role\").Find(&users)\r\n//// SELECT * FROM users;\r\n//// SELECT * FROM orders WHERE user_id IN (1,2,3,4); // has many\r\n//// SELECT * FROM profiles WHERE user_id IN (1,2,3,4); // has one\r\n//// SELECT * FROM roles WHERE id IN (4,5,6); // belongs to\r\n```\r\n\r\n#### Nested Preloading\r\n\r\n```go\r\ndb.Preload(\"Orders.OrderItems\").Find(&users)\r\ndb.Preload(\"Orders\", \"state = ?\", \"paid\").Preload(\"Orders.OrderItems\").Find(&users)\r\n```\r\n\r\n## Update\r\n\r\n```go\r\n// Update an existing struct\r\ndb.First(&user)\r\nuser.Name = \"jinzhu 2\"\r\nuser.Age = 100\r\ndb.Save(&user)\r\n//// UPDATE users SET name='jinzhu 2', age=100, updated_at = '2013-11-17 21:34:10' WHERE id=111;\r\n\r\ndb.Where(\"active = ?\", true).Save(&user)\r\n//// UPDATE users SET name='jinzhu 2', age=100, updated_at = '2013-11-17 21:34:10' WHERE id=111 AND active = true;\r\n\r\n// Update an attribute if it is changed\r\ndb.Model(&user).Update(\"name\", \"hello\")\r\n//// UPDATE users SET name='hello', updated_at = '2013-11-17 21:34:10' WHERE id=111;\r\n\r\ndb.Model(&user).Where(\"active = ?\", true).Update(\"name\", \"hello\")\r\n//// UPDATE users SET name='hello', updated_at = '2013-11-17 21:34:10' WHERE id=111 AND active = true;\r\n\r\ndb.First(&user, 111).Update(\"name\", \"hello\")\r\n//// SELECT * FROM users LIMIT 1;\r\n//// UPDATE users SET name='hello', updated_at = '2013-11-17 21:34:10' WHERE id=111;\r\n\r\n// Update multiple attributes if they are changed\r\ndb.Model(&user).Updates(map[string]interface{}{\"name\": \"hello\", \"age\": 18, \"actived\": false})\r\n\r\n// Update multiple attributes if they are changed (update with struct only works with none zero values)\r\ndb.Model(&user).Updates(User{Name: \"hello\", Age: 18})\r\n//// UPDATE users SET name='hello', age=18, updated_at = '2013-11-17 21:34:10' WHERE id = 111;\r\n```\r\n\r\n### Update Without Callbacks\r\n\r\nBy default, update will call BeforeUpdate, AfterUpdate callbacks, if you want to update w/o callbacks and w/o saving associations:\r\n\r\n```go\r\ndb.Model(&user).UpdateColumn(\"name\", \"hello\")\r\n//// UPDATE users SET name='hello' WHERE id = 111;\r\n\r\n// Update with struct only works with none zero values, or use map[string]interface{}\r\ndb.Model(&user).UpdateColumns(User{Name: \"hello\", Age: 18})\r\n//// UPDATE users SET name='hello', age=18 WHERE id = 111;\r\n```\r\n\r\n### Batch Updates\r\n\r\n```go\r\ndb.Table(\"users\").Where(\"id = ?\", 10).Updates(map[string]interface{}{\"name\": \"hello\", \"age\": 18})\r\n//// UPDATE users SET name='hello', age=18 WHERE id = 10;\r\n\r\n// Update with struct only works with none zero values, or use map[string]interface{}\r\ndb.Model(User{}).Updates(User{Name: \"hello\", Age: 18})\r\n//// UPDATE users SET name='hello', age=18;\r\n\r\n// Callbacks won't run when do batch updates\r\n\r\n// Use `RowsAffected` to get the count of affected records\r\ndb.Model(User{}).Updates(User{Name: \"hello\", Age: 18}).RowsAffected\r\n```\r\n\r\n### Update with SQL Expression\r\n\r\n```go\r\nDB.Model(&product).Update(\"price\", gorm.Expr(\"price * ? + ?\", 2, 100))\r\n//// UPDATE \"products\" SET \"code\" = 'L1212', \"price\" = price * '2' + '100', \"updated_at\" = '2013-11-17 21:34:10' WHERE \"id\" = '2';\r\n\r\nDB.Model(&product).Updates(map[string]interface{}{\"price\": gorm.Expr(\"price * ? + ?\", 2, 100)})\r\n//// UPDATE \"products\" SET \"code\" = 'L1212', \"price\" = price * '2' + '100', \"updated_at\" = '2013-11-17 21:34:10' WHERE \"id\" = '2';\r\n\r\nDB.Model(&product).UpdateColumn(\"quantity\", gorm.Expr(\"quantity - ?\", 1))\r\n//// UPDATE \"products\" SET \"quantity\" = quantity - 1 WHERE \"id\" = '2';\r\n\r\nDB.Model(&product).Where(\"quantity > 1\").UpdateColumn(\"quantity\", gorm.Expr(\"quantity - ?\", 1))\r\n//// UPDATE \"products\" SET \"quantity\" = quantity - 1 WHERE \"id\" = '2' AND quantity > 1;\r\n```\r\n\r\n## Delete\r\n\r\n```go\r\n// Delete an existing record\r\ndb.Delete(&email)\r\n//// DELETE from emails where id=10;\r\n```\r\n\r\n### Batch Delete\r\n\r\n```go\r\ndb.Where(\"email LIKE ?\", \"%jinzhu%\").Delete(Email{})\r\n//// DELETE from emails where email LIKE \"%jinhu%\";\r\n```\r\n\r\n### Soft Delete\r\n\r\nIf struct has `DeletedAt` field, it will get soft delete ability automatically!\r\nThen it won't be deleted from database permanently when call `Delete`.\r\n\r\n```go\r\ndb.Delete(&user)\r\n//// UPDATE users SET deleted_at=\"2013-10-29 10:23\" WHERE id = 111;\r\n\r\n// Batch Delete\r\ndb.Where(\"age = ?\", 20).Delete(&User{})\r\n//// UPDATE users SET deleted_at=\"2013-10-29 10:23\" WHERE age = 20;\r\n\r\n// Soft deleted records will be ignored when query them\r\ndb.Where(\"age = 20\").Find(&user)\r\n//// SELECT * FROM users WHERE age = 20 AND (deleted_at IS NULL OR deleted_at <= '0001-01-02');\r\n\r\n// Find soft deleted records with Unscoped\r\ndb.Unscoped().Where(\"age = 20\").Find(&users)\r\n//// SELECT * FROM users WHERE age = 20;\r\n\r\n// Delete record permanently with Unscoped\r\ndb.Unscoped().Delete(&order)\r\n//// DELETE FROM orders WHERE id=10;\r\n```\r\n\r\n## Associations\r\n\r\n### Has One\r\n\r\n```go\r\n// User has one address\r\ndb.Model(&user).Related(&address)\r\n//// SELECT * FROM addresses WHERE id = 123; // 123 is user's foreign key AddressId\r\n\r\n// Specify the foreign key\r\ndb.Model(&user).Related(&address1, \"BillingAddressId\")\r\n//// SELECT * FROM addresses WHERE id = 123; // 123 is user's foreign key BillingAddressId\r\n```\r\n\r\n### Belongs To\r\n\r\n```go\r\n// Email belongs to user\r\ndb.Model(&email).Related(&user)\r\n//// SELECT * FROM users WHERE id = 111; // 111 is email's foreign key UserId\r\n\r\n// Specify the foreign key\r\ndb.Model(&email).Related(&user, \"ProfileId\")\r\n//// SELECT * FROM users WHERE id = 111; // 111 is email's foreign key ProfileId\r\n```\r\n\r\n### Has Many\r\n\r\n```go\r\n// User has many emails\r\ndb.Model(&user).Related(&emails)\r\n//// SELECT * FROM emails WHERE user_id = 111;\r\n// user_id is the foreign key, 111 is user's primary key's value\r\n\r\n// Specify the foreign key\r\ndb.Model(&user).Related(&emails, \"ProfileId\")\r\n//// SELECT * FROM emails WHERE profile_id = 111;\r\n// profile_id is the foreign key, 111 is user's primary key's value\r\n```\r\n\r\n### Many To Many\r\n\r\n```go\r\n// User has many languages and belongs to many languages\r\ndb.Model(&user).Related(&languages, \"Languages\")\r\n//// SELECT * FROM \"languages\" INNER JOIN \"user_languages\" ON \"user_languages\".\"language_id\" = \"languages\".\"id\" WHERE \"user_languages\".\"user_id\" = 111\r\n// `Languages` is user's column name, this column's tag defined join table like this `gorm:\"many2many:user_languages;\"`\r\n```\r\n\r\nThere is also a mode used to handle many to many relations easily\r\n\r\n```go\r\n// Query\r\ndb.Model(&user).Association(\"Languages\").Find(&languages)\r\n// same as `db.Model(&user).Related(&languages, \"Languages\")`\r\n\r\ndb.Where(\"name = ?\", \"ZH\").First(&languageZH)\r\ndb.Where(\"name = ?\", \"EN\").First(&languageEN)\r\n\r\n// Append\r\ndb.Model(&user).Association(\"Languages\").Append([]Language{languageZH, languageEN})\r\ndb.Model(&user).Association(\"Languages\").Append([]Language{{Name: \"DE\"}})\r\ndb.Model(&user).Association(\"Languages\").Append(Language{Name: \"DE\"})\r\n\r\n// Delete\r\ndb.Model(&user).Association(\"Languages\").Delete([]Language{languageZH, languageEN})\r\ndb.Model(&user).Association(\"Languages\").Delete(languageZH, languageEN)\r\n\r\n// Replace\r\ndb.Model(&user).Association(\"Languages\").Replace([]Language{languageZH, languageEN})\r\ndb.Model(&user).Association(\"Languages\").Replace(Language{Name: \"DE\"}, languageEN)\r\n\r\n// Count\r\ndb.Model(&user).Association(\"Languages\").Count()\r\n// Return the count of languages the user has\r\n\r\n// Clear\r\ndb.Model(&user).Association(\"Languages\").Clear()\r\n// Remove all relations between the user and languages\r\n```\r\n\r\n### Polymorphism\r\n\r\nSupports polymorphic has-many and has-one associations.\r\n\r\n```go\r\n  type Cat struct {\r\n    Id    int\r\n    Name  string\r\n    Toy   Toy `gorm:\"polymorphic:Owner;\"`\r\n  }\r\n\r\n  type Dog struct {\r\n    Id   int\r\n    Name string\r\n    Toy  Toy `gorm:\"polymorphic:Owner;\"`\r\n  }\r\n\r\n  type Toy struct {\r\n    Id        int\r\n    Name      string\r\n    OwnerId   int\r\n    OwnerType string\r\n  }\r\n```\r\nNote: polymorphic belongs-to and many-to-many are explicitly NOT supported, and will throw errors.\r\n\r\n## Advanced Usage\r\n\r\n## FirstOrInit\r\n\r\nGet the first matched record, or initialize a record with search conditions.\r\n\r\n```go\r\n// Unfound\r\ndb.FirstOrInit(&user, User{Name: \"non_existing\"})\r\n//// user -> User{Name: \"non_existing\"}\r\n\r\n// Found\r\ndb.Where(User{Name: \"Jinzhu\"}).FirstOrInit(&user)\r\n//// user -> User{Id: 111, Name: \"Jinzhu\", Age: 20}\r\ndb.FirstOrInit(&user, map[string]interface{}{\"name\": \"jinzhu\"})\r\n//// user -> User{Id: 111, Name: \"Jinzhu\", Age: 20}\r\n```\r\n\r\n### Attrs\r\n\r\nIgnore some values when searching, but use them to initialize the struct if record is not found.\r\n\r\n```go\r\n// Unfound\r\ndb.Where(User{Name: \"non_existing\"}).Attrs(User{Age: 20}).FirstOrInit(&user)\r\n//// SELECT * FROM USERS WHERE name = 'non_existing';\r\n//// user -> User{Name: \"non_existing\", Age: 20}\r\n\r\ndb.Where(User{Name: \"noexisting_user\"}).Attrs(\"age\", 20).FirstOrInit(&user)\r\n//// SELECT * FROM USERS WHERE name = 'non_existing';\r\n//// user -> User{Name: \"non_existing\", Age: 20}\r\n\r\n// Found\r\ndb.Where(User{Name: \"Jinzhu\"}).Attrs(User{Age: 30}).FirstOrInit(&user)\r\n//// SELECT * FROM USERS WHERE name = jinzhu';\r\n//// user -> User{Id: 111, Name: \"Jinzhu\", Age: 20}\r\n```\r\n\r\n### Assign\r\n\r\nIgnore some values when searching, but assign it to the result regardless it is found or not.\r\n\r\n```go\r\n// Unfound\r\ndb.Where(User{Name: \"non_existing\"}).Assign(User{Age: 20}).FirstOrInit(&user)\r\n//// user -> User{Name: \"non_existing\", Age: 20}\r\n\r\n// Found\r\ndb.Where(User{Name: \"Jinzhu\"}).Assign(User{Age: 30}).FirstOrInit(&user)\r\n//// SELECT * FROM USERS WHERE name = jinzhu';\r\n//// user -> User{Id: 111, Name: \"Jinzhu\", Age: 30}\r\n```\r\n\r\n## FirstOrCreate\r\n\r\nGet the first matched record, or create with search conditions.\r\n\r\n```go\r\n// Unfound\r\ndb.FirstOrCreate(&user, User{Name: \"non_existing\"})\r\n//// INSERT INTO \"users\" (name) VALUES (\"non_existing\");\r\n//// user -> User{Id: 112, Name: \"non_existing\"}\r\n\r\n// Found\r\ndb.Where(User{Name: \"Jinzhu\"}).FirstOrCreate(&user)\r\n//// user -> User{Id: 111, Name: \"Jinzhu\"}\r\n```\r\n\r\n### Attrs\r\n\r\nIgnore some values when searching, but use them to create the struct if record is not found. like `FirstOrInit`\r\n\r\n```go\r\n// Unfound\r\ndb.Where(User{Name: \"non_existing\"}).Attrs(User{Age: 20}).FirstOrCreate(&user)\r\n//// SELECT * FROM users WHERE name = 'non_existing';\r\n//// INSERT INTO \"users\" (name, age) VALUES (\"non_existing\", 20);\r\n//// user -> User{Id: 112, Name: \"non_existing\", Age: 20}\r\n\r\n// Found\r\ndb.Where(User{Name: \"jinzhu\"}).Attrs(User{Age: 30}).FirstOrCreate(&user)\r\n//// SELECT * FROM users WHERE name = 'jinzhu';\r\n//// user -> User{Id: 111, Name: \"jinzhu\", Age: 20}\r\n```\r\n\r\n### Assign\r\n\r\nIgnore some values when searching, but assign it to the record regardless it is found or not, then save back to database. like `FirstOrInit`\r\n\r\n```go\r\n// Unfound\r\ndb.Where(User{Name: \"non_existing\"}).Assign(User{Age: 20}).FirstOrCreate(&user)\r\n//// SELECT * FROM users WHERE name = 'non_existing';\r\n//// INSERT INTO \"users\" (name, age) VALUES (\"non_existing\", 20);\r\n//// user -> User{Id: 112, Name: \"non_existing\", Age: 20}\r\n\r\n// Found\r\ndb.Where(User{Name: \"jinzhu\"}).Assign(User{Age: 30}).FirstOrCreate(&user)\r\n//// SELECT * FROM users WHERE name = 'jinzhu';\r\n//// UPDATE users SET age=30 WHERE id = 111;\r\n//// user -> User{Id: 111, Name: \"jinzhu\", Age: 30}\r\n```\r\n\r\n## Select\r\n\r\n```go\r\ndb.Select(\"name, age\").Find(&users)\r\n//// SELECT name, age FROM users;\r\n\r\ndb.Select([]string{\"name\", \"age\"}).Find(&users)\r\n//// SELECT name, age FROM users;\r\n\r\ndb.Table(\"users\").Select(\"COALESCE(age,?)\", 42).Rows()\r\n//// SELECT COALESCE(age,'42') FROM users;\r\n```\r\n\r\n## Order\r\n\r\n```go\r\ndb.Order(\"age desc, name\").Find(&users)\r\n//// SELECT * FROM users ORDER BY age desc, name;\r\n\r\n// Multiple orders\r\ndb.Order(\"age desc\").Order(\"name\").Find(&users)\r\n//// SELECT * FROM users ORDER BY age desc, name;\r\n\r\n// ReOrder\r\ndb.Order(\"age desc\").Find(&users1).Order(\"age\", true).Find(&users2)\r\n//// SELECT * FROM users ORDER BY age desc; (users1)\r\n//// SELECT * FROM users ORDER BY age; (users2)\r\n```\r\n\r\n## Limit\r\n\r\n```go\r\ndb.Limit(3).Find(&users)\r\n//// SELECT * FROM users LIMIT 3;\r\n\r\n// Cancel limit condition with -1\r\ndb.Limit(10).Find(&users1).Limit(-1).Find(&users2)\r\n//// SELECT * FROM users LIMIT 10; (users1)\r\n//// SELECT * FROM users; (users2)\r\n```\r\n\r\n## Offset\r\n\r\n```go\r\ndb.Offset(3).Find(&users)\r\n//// SELECT * FROM users OFFSET 3;\r\n\r\n// Cancel offset condition with -1\r\ndb.Offset(10).Find(&users1).Offset(-1).Find(&users2)\r\n//// SELECT * FROM users OFFSET 10; (users1)\r\n//// SELECT * FROM users; (users2)\r\n```\r\n\r\n## Count\r\n\r\n```go\r\ndb.Where(\"name = ?\", \"jinzhu\").Or(\"name = ?\", \"jinzhu 2\").Find(&users).Count(&count)\r\n//// SELECT * from USERS WHERE name = 'jinzhu' OR name = 'jinzhu 2'; (users)\r\n//// SELECT count(*) FROM users WHERE name = 'jinzhu' OR name = 'jinzhu 2'; (count)\r\n\r\ndb.Model(User{}).Where(\"name = ?\", \"jinzhu\").Count(&count)\r\n//// SELECT count(*) FROM users WHERE name = 'jinzhu'; (count)\r\n\r\ndb.Table(\"deleted_users\").Count(&count)\r\n//// SELECT count(*) FROM deleted_users;\r\n```\r\n\r\n## Pluck\r\n\r\nGet selected attributes as map\r\n\r\n```go\r\nvar ages []int64\r\ndb.Find(&users).Pluck(\"age\", &ages)\r\n\r\nvar names []string\r\ndb.Model(&User{}).Pluck(\"name\", &names)\r\n\r\ndb.Table(\"deleted_users\").Pluck(\"name\", &names)\r\n\r\n// Requesting more than one column? Do it like this:\r\ndb.Select(\"name, age\").Find(&users)\r\n```\r\n\r\n## Raw SQL\r\n\r\n```go\r\ndb.Exec(\"DROP TABLE users;\")\r\ndb.Exec(\"UPDATE orders SET shipped_at=? WHERE id IN (?)\", time.Now, []int64{11,22,33})\r\n```\r\n\r\n## Row & Rows\r\n\r\nIt is even possible to get query result as `*sql.Row` or `*sql.Rows`\r\n\r\n```go\r\nrow := db.Table(\"users\").Where(\"name = ?\", \"jinzhu\").Select(\"name, age\").Row() // (*sql.Row)\r\nrow.Scan(&name, &age)\r\n\r\nrows, err := db.Model(User{}).Where(\"name = ?\", \"jinzhu\").Select(\"name, age, email\").Rows() // (*sql.Rows, error)\r\ndefer rows.Close()\r\nfor rows.Next() {\r\n\t...\r\n\trows.Scan(&name, &age, &email)\r\n\t...\r\n}\r\n\r\n// Raw SQL\r\nrows, err := db.Raw(\"select name, age, email from users where name = ?\", \"jinzhu\").Rows() // (*sql.Rows, error)\r\ndefer rows.Close()\r\nfor rows.Next() {\r\n\t...\r\n\trows.Scan(&name, &age, &email)\r\n\t...\r\n}\r\n```\r\n\r\n## Scan\r\n\r\nScan results into another struct.\r\n\r\n```go\r\ntype Result struct {\r\n\tName string\r\n\tAge  int\r\n}\r\n\r\nvar result Result\r\ndb.Table(\"users\").Select(\"name, age\").Where(\"name = ?\", 3).Scan(&result)\r\n\r\n// Raw SQL\r\ndb.Raw(\"SELECT name, age FROM users WHERE name = ?\", 3).Scan(&result)\r\n```\r\n\r\n## Group & Having\r\n\r\n```go\r\nrows, err := db.Table(\"orders\").Select(\"date(created_at) as date, sum(amount) as total\").Group(\"date(created_at)\").Rows()\r\nfor rows.Next() {\r\n\t...\r\n}\r\n\r\nrows, err := db.Table(\"orders\").Select(\"date(created_at) as date, sum(amount) as total\").Group(\"date(created_at)\").Having(\"sum(amount) > ?\", 100).Rows()\r\nfor rows.Next() {\r\n\t...\r\n}\r\n\r\ntype Result struct {\r\n\tDate  time.Time\r\n\tTotal int64\r\n}\r\ndb.Table(\"orders\").Select(\"date(created_at) as date, sum(amount) as total\").Group(\"date(created_at)\").Having(\"sum(amount) > ?\", 100).Scan(&results)\r\n```\r\n\r\n## Joins\r\n\r\n```go\r\nrows, err := db.Table(\"users\").Select(\"users.name, emails.email\").Joins(\"left join emails on emails.user_id = users.id\").Rows()\r\nfor rows.Next() {\r\n\t...\r\n}\r\n\r\ndb.Table(\"users\").Select(\"users.name, emails.email\").Joins(\"left join emails on emails.user_id = users.id\").Scan(&results)\r\n\r\n// find a user by email address\r\ndb.Joins(\"inner join emails on emails.user_id = users.id\").Where(\"emails.email = ?\", \"x@example.org\").Find(&user)\r\n\r\n// find all email addresses for a user\r\ndb.Joins(\"left join users on users.id = emails.user_id\").Where(\"users.name = ?\", \"jinzhu\").Find(&emails)\r\n```\r\n\r\n## Transactions\r\n\r\nTo perform a set of operations within a transaction, the general flow is as below.\r\nThe database handle returned from ``` db.Begin() ``` should be used for all operations within the transaction.\r\n(Note that all individual save and delete operations are run in a transaction by default.)\r\n\r\n```go\r\n// begin\r\ntx := db.Begin()\r\n\r\n// do some database operations (use 'tx' from this point, not 'db')\r\ntx.Create(...)\r\n...\r\n\r\n// rollback in case of error\r\ntx.Rollback()\r\n\r\n// Or commit if all is ok\r\ntx.Commit()\r\n```\r\n\r\n### A Specific Example\r\n```\r\nfunc CreateAnimals(db *gorm.DB) err {\r\n  tx := db.Begin()\r\n  // Note the use of tx as the database handle once you are within a transaction\r\n\r\n  if err := tx.Create(&Animal{Name: \"Giraffe\"}).Error; err != nil {\r\n     tx.Rollback()\r\n     return err\r\n  }\r\n\r\n  if err := tx.Create(&Animal{Name: \"Lion\"}).Error; err != nil {\r\n     tx.Rollback()\r\n     return err\r\n  }\r\n\r\n  tx.Commit()\r\n  return nil\r\n}\r\n```\r\n\r\n## Scopes\r\n\r\n```go\r\nfunc AmountGreaterThan1000(db *gorm.DB) *gorm.DB {\r\n\treturn db.Where(\"amount > ?\", 1000)\r\n}\r\n\r\nfunc PaidWithCreditCard(db *gorm.DB) *gorm.DB {\r\n\treturn db.Where(\"pay_mode_sign = ?\", \"C\")\r\n}\r\n\r\nfunc PaidWithCod(db *gorm.DB) *gorm.DB {\r\n\treturn db.Where(\"pay_mode_sign = ?\", \"C\")\r\n}\r\n\r\nfunc OrderStatus(status []string) func (db *gorm.DB) *gorm.DB {\r\n\treturn func (db *gorm.DB) *gorm.DB {\r\n\t\treturn db.Scopes(AmountGreaterThan1000).Where(\"status in (?)\", status)\r\n\t}\r\n}\r\n\r\ndb.Scopes(AmountGreaterThan1000, PaidWithCreditCard).Find(&orders)\r\n// Find all credit card orders and amount greater than 1000\r\n\r\ndb.Scopes(AmountGreaterThan1000, PaidWithCod).Find(&orders)\r\n// Find all COD orders and amount greater than 1000\r\n\r\ndb.Scopes(OrderStatus([]string{\"paid\", \"shipped\"})).Find(&orders)\r\n// Find all paid, shipped orders\r\n```\r\n\r\n## Callbacks\r\n\r\nCallbacks are methods defined on the pointer of struct.\r\nIf any callback returns an error, gorm will stop future operations and rollback all changes.\r\n\r\nHere is the list of all available callbacks:\r\n(listed in the same order in which they will get called during the respective operations)\r\n\r\n### Creating An Object\r\n\r\n```go\r\nBeforeSave\r\nBeforeCreate\r\n// save before associations\r\n// save self\r\n// save after associations\r\nAfterCreate\r\nAfterSave\r\n```\r\n### Updating An Object\r\n\r\n```go\r\nBeforeSave\r\nBeforeUpdate\r\n// save before associations\r\n// save self\r\n// save after associations\r\nAfterUpdate\r\nAfterSave\r\n```\r\n\r\n### Destroying An Object\r\n\r\n```go\r\nBeforeDelete\r\n// delete self\r\nAfterDelete\r\n```\r\n\r\n### After Find\r\n\r\n```go\r\n// load data from database\r\nAfterFind\r\n```\r\n\r\n### Example\r\n\r\n```go\r\nfunc (u *User) BeforeUpdate() (err error) {\r\n\tif u.readonly() {\r\n\t\terr = errors.New(\"read only user\")\r\n\t}\r\n\treturn\r\n}\r\n\r\n// Rollback the insertion if user's id greater than 1000\r\nfunc (u *User) AfterCreate() (err error) {\r\n\tif (u.Id > 1000) {\r\n\t\terr = errors.New(\"user id is already greater than 1000\")\r\n\t}\r\n\treturn\r\n}\r\n```\r\n\r\nAs you know, save/delete operations in gorm are running in a transaction,\r\nThis is means if changes made in the transaction is not visiable unless it is commited,\r\nSo if you want to use those changes in your callbacks, you need to run SQL in same transaction.\r\nFortunately, gorm support pass transaction to callbacks as you needed, you could do it like this:\r\n\r\n```go\r\nfunc (u *User) AfterCreate(tx *gorm.DB) (err error) {\r\n\ttx.Model(u).Update(\"role\", \"admin\")\r\n\treturn\r\n}\r\n```\r\n\r\n## Specifying The Table Name\r\n\r\n```go\r\n// Create `deleted_users` table with struct User's definition\r\ndb.Table(\"deleted_users\").CreateTable(&User{})\r\n\r\nvar deleted_users []User\r\ndb.Table(\"deleted_users\").Find(&deleted_users)\r\n//// SELECT * FROM deleted_users;\r\n\r\ndb.Table(\"deleted_users\").Where(\"name = ?\", \"jinzhu\").Delete()\r\n//// DELETE FROM deleted_users WHERE name = 'jinzhu';\r\n```\r\n\r\n### Specifying The Table Name For A Struct Permanently with TableName\r\n\r\n```go\r\ntype Cart struct {\r\n}\r\n\r\nfunc (c Cart) TableName() string {\r\n\treturn \"shopping_cart\"\r\n}\r\n\r\nfunc (u User) TableName() string {\r\n\tif u.Role == \"admin\" {\r\n\t\treturn \"admin_users\"\r\n\t} else {\r\n\t\treturn \"users\"\r\n\t}\r\n}\r\n```\r\n\r\n## Error Handling\r\n\r\n```go\r\nquery := db.Where(\"name = ?\", \"jinzhu\").First(&user)\r\nquery := db.First(&user).Limit(10).Find(&users)\r\n// query.Error will return the last happened error\r\n\r\n// So you could do error handing in your application like this:\r\nif err := db.Where(\"name = ?\", \"jinzhu\").First(&user).Error; err != nil {\r\n\t// error handling...\r\n}\r\n\r\n// RecordNotFound\r\n// If no record found when you query data, gorm will return RecordNotFound error, you could check it like this:\r\ndb.Where(\"name = ?\", \"hello world\").First(&User{}).Error == gorm.RecordNotFound\r\n// Or use the shortcut method\r\ndb.Where(\"name = ?\", \"hello world\").First(&user).RecordNotFound()\r\n\r\nif db.Model(&user).Related(&credit_card).RecordNotFound() {\r\n\t// no credit card found error handling\r\n}\r\n```\r\n\r\n## Logger\r\n\r\nGorm has built-in logger support\r\n\r\n```go\r\n// Enable Logger\r\ndb.LogMode(true)\r\n\r\n// Diable Logger\r\ndb.LogMode(false)\r\n\r\n// Debug a single operation\r\ndb.Debug().Where(\"name = ?\", \"jinzhu\").First(&User{})\r\n```\r\n\r\n![logger](https://raw.github.com/jinzhu/gorm/master/images/logger.png)\r\n\r\n### Customize Logger\r\n\r\n```go\r\n// Refer gorm's default logger for how to: https://github.com/jinzhu/gorm/blob/master/logger.go#files\r\ndb.SetLogger(gorm.Logger{revel.TRACE})\r\ndb.SetLogger(log.New(os.Stdout, \"\\r\\n\", 0))\r\n```\r\n\r\n## Existing Schema\r\n\r\nIf you have an existing database schema, and the primary key field is different from `id`, you can add a tag to the field structure to specify that this field is a primary key.\r\n\r\n```go\r\ntype Animal struct {\r\n\tAnimalId     int64 `gorm:\"primary_key\"`\r\n\tBirthday     time.Time `sql:\"DEFAULT:current_timestamp\"`\r\n\tName         string `sql:\"default:'galeone'\"`\r\n\tAge          int64\r\n}\r\n```\r\n\r\nIf your column names differ from the struct fields, you can specify them like this:\r\n\r\n```go\r\ntype Animal struct {\r\n\tAnimalId    int64     `gorm:\"column:beast_id;primary_key\"`\r\n\tBirthday    time.Time `gorm:\"column:day_of_the_beast\"`\r\n\tAge         int64     `gorm:\"column:age_of_the_beast\"`\r\n}\r\n```\r\n\r\n## Composite Primary Key\r\n\r\n```go\r\ntype Product struct {\r\n\tID           string `gorm:\"primary_key\"`\r\n\tLanguageCode string `gorm:\"primary_key\"`\r\n}\r\n```\r\n\r\n## Database Indexes & Foreign Key\r\n\r\n```go\r\n// Add foreign key\r\n// 1st param : foreignkey field\r\n// 2nd param : destination table(id)\r\n// 3rd param : ONDELETE\r\n// 4th param : ONUPDATE\r\ndb.Model(&User{}).AddForeignKey(\"city_id\", \"cities(id)\", \"RESTRICT\", \"RESTRICT\")\r\n\r\n// Add index\r\ndb.Model(&User{}).AddIndex(\"idx_user_name\", \"name\")\r\n\r\n// Multiple column index\r\ndb.Model(&User{}).AddIndex(\"idx_user_name_age\", \"name\", \"age\")\r\n\r\n// Add unique index\r\ndb.Model(&User{}).AddUniqueIndex(\"idx_user_name\", \"name\")\r\n\r\n// Multiple column unique index\r\ndb.Model(&User{}).AddUniqueIndex(\"idx_user_name_age\", \"name\", \"age\")\r\n\r\n// Remove index\r\ndb.Model(&User{}).RemoveIndex(\"idx_user_name\")\r\n```\r\n\r\n## Default values\r\n\r\n```go\r\ntype Animal struct {\r\n\tID   int64\r\n\tName string `sql:\"default:'galeone'\"`\r\n\tAge  int64\r\n}\r\n```\r\n\r\nIf you have defined a default value in the `sql` tag, the generated create SQl will ignore these fields if it is blank.\r\n\r\nEg.\r\n\r\n```go\r\ndb.Create(&Animal{Age: 99, Name: \"\"})\r\n```\r\n\r\nThe generated SQL will be:\r\n\r\n```sql\r\nINSERT INTO animals(\"age\") values('99');\r\n```\r\n\r\nThe same thing occurs in update statements.\r\n\r\n## More examples with query chain\r\n\r\n```go\r\ndb.First(&first_article).Count(&total_count).Limit(10).Find(&first_page_articles).Offset(10).Find(&second_page_articles)\r\n//// SELECT * FROM articles LIMIT 1; (first_article)\r\n//// SELECT count(*) FROM articles; (total_count)\r\n//// SELECT * FROM articles LIMIT 10; (first_page_articles)\r\n//// SELECT * FROM articles LIMIT 10 OFFSET 10; (second_page_articles)\r\n\r\n\r\ndb.Where(\"created_at > ?\", \"2013-10-10\").Find(&cancelled_orders, \"state = ?\", \"cancelled\").Find(&shipped_orders, \"state = ?\", \"shipped\")\r\n//// SELECT * FROM orders WHERE created_at > '2013/10/10' AND state = 'cancelled'; (cancelled_orders)\r\n//// SELECT * FROM orders WHERE created_at > '2013/10/10' AND state = 'shipped'; (shipped_orders)\r\n\r\n\r\n// Use variables to keep query chain\r\ntodays_orders := db.Where(\"created_at > ?\", \"2013-10-29\")\r\ncancelled_orders := todays_orders.Where(\"state = ?\", \"cancelled\")\r\nshipped_orders := todays_orders.Where(\"state = ?\", \"shipped\")\r\n\r\n\r\n// Search with shared conditions for different tables\r\ndb.Where(\"product_name = ?\", \"fancy_product\").Find(&orders).Find(&shopping_carts)\r\n//// SELECT * FROM orders WHERE product_name = 'fancy_product'; (orders)\r\n//// SELECT * FROM carts WHERE product_name = 'fancy_product'; (shopping_carts)\r\n\r\n\r\n// Search with shared conditions from different tables with specified table\r\ndb.Where(\"mail_type = ?\", \"TEXT\").Find(&users1).Table(\"deleted_users\").Find(&users2)\r\n//// SELECT * FROM users WHERE mail_type = 'TEXT'; (users1)\r\n//// SELECT * FROM deleted_users WHERE mail_type = 'TEXT'; (users2)\r\n\r\n\r\n// FirstOrCreate example\r\ndb.Where(\"email = ?\", \"x@example.org\").Attrs(User{RegisteredIp: \"111.111.111.111\"}).FirstOrCreate(&user)\r\n//// SELECT * FROM users WHERE email = 'x@example.org';\r\n//// INSERT INTO \"users\" (email,registered_ip) VALUES (\"x@example.org\", \"111.111.111.111\")  // if record not found\r\n```\r\n\r\n## TODO\r\n* Github Pages\r\n\r\n# Author\r\n\r\n**jinzhu**\r\n\r\n* <http://github.com/jinzhu>\r\n* <wosmvp@gmail.com>\r\n* <http://twitter.com/zhangjinzhu>\r\n\r\n## License\r\n\r\nReleased under the [MIT License](https://github.com/jinzhu/gorm/blob/master/License).\r\n","google":"UA-23459165-4","note":"Don't delete this file! It's used internally to help with page regeneration."}